#7.2 JSON
JSON(Javascript Object Notation) is a lightweight data exchange language which is based on text description, its advantanges including self-descriptive, easy to understand, etc. Even though it is a sub-set of Javascript, JSON uses different text format to become an independent language, and has some similarities with C-family languages.

The biggest difference between JSON and XML is that XML is a complete mark language, but JSON is not. JSON is smaller and faster than XML, therefore it's much easier and quicker to parse in browsers, which is an important reason that many open platforms choose to use JSON as their data exchange interface language.

Since JSON is becoming more important in web development, let's take a look at the level of support JSON in Go. Actually, the standard library has very good support for encoding and decoding JSON.

Here we use JSON to represent the example in previous section:

	{"servers":[{"serverName":"Shanghai_VPN","serverIP":"127.0.0.1"},{"serverName":"Beijing_VPN","serverIP":"127.0.0.2"}]}
	
The rest of this section will use this JSON data to introduce you how to operate JSON in Go.

##Parse JSON
###Parse to struct
Suppose we have JSON in above example, how can we parse this data and map to strcut in Go? Go has following function to do this:

	func Unmarshal(data []byte, v interface{}) error

We can use this function to achieve our goal, here is a complete example:

	package main
	
	import (
	    "encoding/json"
	    "fmt"
	)
	
	type Server struct {
	    ServerName string
	    ServerIP   string
	}
	
	type Serverslice struct {
	    Servers []Server
	}

	func main() {
	    var s Serverslice
	    str := `{"servers":[{"serverName":"Shanghai_VPN","serverIP":"127.0.0.1"},{"serverName":"Beijing_VPN","serverIP":"127.0.0.2"}]}`
	    json.Unmarshal([]byte(str), &s)
	    fmt.Println(s)
	}
	
In above example, we defined a correspding struct in Go for our JSON, slice for array, field name for key in JSON, but how does Go know which JSON data is for specific struct filed? Suppose we have a key called `Foo` in JSON, how to find corresponding field?

- First, try to find the exported field(capitalized) whose tag contains `Foo`.
- Then, try to find the field whose name is `Foo`.
- Finally, try to find something like `FOO` or `FoO` without case sensitive.

You may notice that all fields that are going to be assigned should be exported, and Go only assigns fields that can be found at the same time, and ignores all the others. This is good because when you receive a very large JSON data but you only need some of them, you can easily discard.

###Parse to interface
When we know what kind of JSON we're going to have, we parse JSON to specific struct, but what if we don't know?

We know that interface{} can be everything in Go, so it is the best container to save our unknown format JSON. JSON package uses `map[string]interface{}` and `[]interface{}` to save all kinds of JSON objects and array. Here is a list of mapping relation:

- `bool` represents `JSON booleans`,
- `float64` represents `JSON numbers`,
- `string` represents `JSON strings`,
- `nil` represents `JSON null`.

Suppose we have following JSON data:

	b := []byte(`{"Name":"Wednesday","Age":6,"Parents":["Gomez","Morticia"]}`)

Now we parse this JSON to interface{}:

	var f interface{}
	err := json.Unmarshal(b, &f)

The `f` stores a map, where keys are strings and values interface{}.

	f = map[string]interface{}{
	    "Name": "Wednesday",
	    "Age":  6,
	    "Parents": []interface{}{
	        "Gomez",
	        "Morticia",
	    },
	}

So, how to access these data? Type assertion.

	m := f.(map[string]interface{})

After asserted, you can use following code to access data:

	for k, v := range m {
	    switch vv := v.(type) {
	    case string:
	        fmt.Println(k, "is string", vv)
	    case int:
	        fmt.Println(k, "is int", vv)
	    case float64:
	        fmt.Println(k,"is float64",vv)
	    case []interface{}:
	        fmt.Println(k, "is an array:")
	        for i, u := range vv {
	            fmt.Println(i, u)
	        }
	    default:
	        fmt.Println(k, "is of a type I don't know how to handle")
	    }
	}
	
As you can see, we can parse unknown format JSON through interface{} and type assert now.

The above example is the official solution, but type assert is not always convenient, so I recommand one open source project called `simplejson` and launched by bitly. Here is an exmaple of how to use this project to deal with unknown format JSON:

	js, err := NewJson([]byte(`{
	    "test": {
	        "array": [1, "2", 3],
	        "int": 10,
	        "float": 5.150,
	        "bignum": 9223372036854775807,
	        "string": "simplejson",
	        "bool": true
	    }
	}`))
	
	arr, _ := js.Get("test").Get("array").Array()
	i, _ := js.Get("test").Get("int").Int()
	ms := js.Get("test").Get("string").MustString()
	
It's not hard to see how convenient it is, see more information: [https://github.com/bitly/go-simplejson](https://github.com/bitly/go-simplejson).

##Produce JSON
我们开发很多应用的时候，最后都是要输出JSON数据串，那么如何来处理呢？JSON包里面通过Marshal函数来处理，函数定义如下：

	func Marshal(v interface{}) ([]byte, error)

假设我们还是需要生成上面的服务器列表信息，那么如何来处理呢？请看下面的例子：

	package main
	
	import (
	    "encoding/json"
	    "fmt"
	)
	
	type Server struct {
	    ServerName string
	    ServerIP   string
	}
	
	type Serverslice struct {
	    Servers []Server
	}
	
	func main() {
	    var s Serverslice
	    s.Servers = append(s.Servers, Server{ServerName: "Shanghai_VPN", ServerIP: "127.0.0.1"})
	    s.Servers = append(s.Servers, Server{ServerName: "Beijing_VPN", ServerIP: "127.0.0.2"})
	    b, err := json.Marshal(s)
	    if err != nil {
	        fmt.Println("json err:", err)
	    }
	    fmt.Println(string(b))
	}
	
输出如下内容：

	{"Servers":[{"ServerName":"Shanghai_VPN","ServerIP":"127.0.0.1"},{"ServerName":"Beijing_VPN","ServerIP":"127.0.0.2"}]}
	
我们看到上面的输出字段名都是大写的，如果你想用小写的怎么办呢？把结构体的字段名改成小写的？JSON输出的时候必须注意，只有导出的字段才会被输出，如果修改字段名，那么就会发现什么都不会输出，所以必须通过struct tag定义来实现：

	type Server struct {
	    ServerName string `json:"serverName"`
	    ServerIP   string `json:"serverIP"`
	}
	
	type Serverslice struct {
	    Servers []Server `json:"servers"`
	}
	
通过修改上面的结构体定义，输出的JSON串就和我们最开始定义的JSON串保持一致了。

针对JSON的输出，我们在定义struct tag的时候需要注意的几点是:

- 字段的tag是"-"，那么这个字段不会输出到JSON
- tag中带有自定义名称，那么这个自定义名称会出现在JSON的字段名中，例如上面例子中serverName
- tag中如果带有"omitempty"选项，那么如果该字段值为空，就不会输出到JSON串中
- 如果字段类型是bool, string, int, int64等，而tag中带有",string"选项，那么这个字段在输出到JSON的时候会把该字段对应的值转换成JSON字符串

举例来说：

	type Server struct {
	    // ID 不会导出到JSON中
	    ID int `json:"-"`
	
	    // ServerName 的值会进行二次JSON编码
	    ServerName  string `json:"serverName"`
	    ServerName2 string `json:"serverName2,string"`
	
	    // 如果 ServerIP 为空，则不输出到JSON串中
	    ServerIP   string `json:"serverIP,omitempty"`
	}
	
	s := Server {
	    ID:         3,
	    ServerName:  `Go "1.0" `,
	    ServerName2: `Go "1.0" `,
	    ServerIP:   ``,
	}
	b, _ := json.Marshal(s)
	os.Stdout.Write(b)
	
会输出以下内容：

	{"serverName":"Go \"1.0\" ","serverName2":"\"Go \\\"1.0\\\" \""}
	
Marshal函数只有在转换成功的时候才会返回数据，在转换的过程中我们需要注意几点：

- JSON对象只支持string作为key，所以要编码一个map，那么必须是map[string]T这种类型(T是Go语言中任意的类型)
- Channel, complex和function是不能被编码成JSON的
- 嵌套的数据是不能编码的，不然会让JSON编码进入死循环
- 指针在编码的时候会输出指针指向的内容，而空指针会输出null

本小节，我们介绍了如何使用Go语言的json标准包来编解码JSON数据，同时也简要介绍了如何使用第三方包go-simplejson来在一些情况下简化操作，学会并熟练运用它们将对我们接下来的Web开发相当重要。

##Links
- [Directory](preface.md)
- Previous section: [XML](07.1.md)
- Next section: [Regex](07.3.md)