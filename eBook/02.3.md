#2.3 Control statements and functions
In this section, we are goning to talk about control statements and function operation in Go.

##Control statement
The greastet inventions in programming language is flow control. Because of them, you are able to use simple control statements represent complex logic. There are three categories, conditional, cycle control and unconditional jump.

###if
`if` should be the most common keyword in your programs. If it meets the condtions then does something, does something else if not.

`if` doesn't need parentheses in Go.

	if x > 10 {
    	fmt.Println("x is greater than 10")
	} else {
    	fmt.Println("x is less than 10")
	} 
	
The most useful thing of `if` in Go is that it can contains one initialization statement before the conditional statement. The scope of variables which are defined in this initialization statement is only in the block of `if`.

	// initialize x, then check if x greater than 
	if x := computedValue(); x > 10 {
    	fmt.Println("x is greater than 10")
	} else {
    	fmt.Println("x is less than 10")
	}

	// the following code will not compile
	fmt.Println(x)
	
Use if-else for multiple conditions.

	if integer == 3 {
    	fmt.Println("The integer is equal to 3")
	} else if integer < 3 {
    	fmt.Println("The integer is less than 3")
	} else {
    	fmt.Println("The integer is greater than 3")
	}
	
###goto
Go has `goto`, but be careful when you use it. `goto` have to jump to the `label` that in the body of same function.

	func myFunc() {
    	i := 0
	Here:   // lable ends with ":"
    	println(i)
    	i++
    	goto Here   // jump to lebale "Here"
	}
	
Label name is case sensitive.

###for
`for` is the most powerful control logic in Go, it can read data in loops and iterative operations, just like `while`.

	for expression1; expression2; expression3 {
    	//...
	}
	
`expression1`, `expression2` and `expression3` are all expressions obviously, where `expression1` and `expression3` are variable defination or return values from functions, and `expression2` is a conditional statment. `expression1` will be exectured before the loop, and `expression3` will be after.

An example is more useful than hundreds of words.

	package main
	import "fmt"

	func main(){
    	sum := 0;
    	for index:=0; index < 10 ; index++ {
        	sum += index
    	}
    	fmt.Println("sum is equal to ", sum)
	}
	// Print：sum is equal to 45

Sometimes we need multiple assignments, but Go doesn't have operator `,`, so we use parallel assginment like `i, j = i + 1, j - 1`.

We can omit `expression1` and `expression3` if they are not necessary.

	sum := 1
	for ; sum < 1000;  {
    	sum += sum
	}
	
Omit `;` as well. Feel familiar? Yes, it's `while`.

	sum := 1
	for sum < 1000 {
    	sum += sum
	}
	
There are two important operations in loops which are `break` and `continue`. `break` jumps out the loop, and `continue` skips current loop and starts next one. If you have nested loops, use `break` with labels together.

	for index := 10; index>0; index-- {
    	if index == 5{
        	break // 或者continue
    	}
    	fmt.Println(index)
	}
	// break prints 10、9、8、7、6
	// continue prints 10、9、8、7、6、4、3、2、1
	
`for` could read data from `slice` and `map` when it is used with `range`.

	for k,v:=range map {
    	fmt.Println("map's key:",k)
    	fmt.Println("map's val:",v)
	}
	
Because Go support multi-value return and gives compile errors when you don't use values that was defined, so you may want to use `_` to discard some return values. 

	for _, v := range map{
    	fmt.Println("map's val:", v)
	}
	
###switch
Sometimes you may think you use too much `if-else` to implement some logic, also it's not looking nice and herd to maintain in the future. Now it's time to use `switch` to slove these problems.

	switch sExpr {
	case expr1:
    	some instructions
	case expr2:
    	some other instructions
	case expr3:
    	some other instructions
	default:
    	other code
	}
	
The type of `sExpr`, `expr1`, `expr2`, and `expr3` must be the same. `switch` is very flexible, conditions don't have to be constants, it executes from top to down until it matchs conditions. If there is no statement after keyword `swtich`, then it matchs `true`.

	i := 10
	switch i {
	case 1:
    	fmt.Println("i is equal to 1")
	case 2, 3, 4:
    	fmt.Println("i is equal to 2, 3 or 4")
	case 10:
    	fmt.Println("i is equal to 10")
	default:
    	fmt.Println("All I know is that i is an 	integer")
	}
	
In fifth line, we put many values in one `case`, and we don't need `break` in the end of `case` body. It will jump out of switch body once it matched any case. If you want to continue to match more cases, you need use statement `fallthrough`.

	integer := 6
	switch integer {
    	case 4:
    		fmt.Println("The integer was <= 4")
    		fallthrough
    	case 5:
    		fmt.Println("The integer was <= 5")
    		fallthrough
    	case 6:
    		fmt.Println("The integer was <= 6")
    		fallthrough
    	case 7:
    		fmt.Println("The integer was <= 7")
    		fallthrough
    	case 8:
    		fmt.Println("The integer was <= 8")
    		fallthrough
    	default:
    		fmt.Println("default case")
	}
	
This program prints following information.

	The integer was <= 6
	The integer was <= 7
	The integer was <= 8
	default case

##Functions
Function is the core design of Go, we use keyword `func` to define functions.

	func funcName(input1 type1, input2 type2) (output1 type1, output2 type2) {
    	// function body
    	// multi-value return
    	return value1, value2
	}
	
We can get following information from above example.

- Use keyword `func` to define a function `funcName`.
- Functions have zero or one or more than one arguments, argument type after the argument name and broke up by `,`.
- Functions can return multiple values.
- There are two return values named `output1` and `output2`, you can omit name and use type only.
- If there is only one return value and you omited the name, you don't need brackets for return values anymore.
- If the function doesn't have return values, you can omit return part.
- If the function has return values, you have to use `return` statement in some places in the body of function.

Let's see one practical example. (calculate maximum value)

	package main
	import "fmt"

	// return greater value between a and b
	func max(a, b int) int {
    	if a > b {
        	return a
    	}
    	return b
	}

	func main() {
    	x := 3
    	y := 4
    	z := 5

    	max_xy := max(x, y) // call function max(x, y)
    	max_xz := max(x, z) // call function max(x, z)

    	fmt.Printf("max(%d, %d) = %d\n", x, y, max_xy)
    	fmt.Printf("max(%d, %d) = %d\n", x, z, max_xz)
    	fmt.Printf("max(%d, %d) = %d\n", y, z, max(y,z)) // call function here
	}

In the above example, there are two arguments in function `max`, their type are both `int`, so the first type can be omited, like `a, b int` instead of `a int, b int`. Same rules for more arguments. Notice here the `max` only have one return value, so here we only write type of return value, this is a short form.

###Multi-value return
One thing that Go is better than C is that it supports multi-value return.

We use above example here.

	package main
	import "fmt"

	// return results of A + B and A * B
	func SumAndProduct(A, B int) (int, int) {
    return A+B, A*B
	}

	func main() {
    	x := 3
    	y := 4

    	xPLUSy, xTIMESy := SumAndProduct(x, y)

    	fmt.Printf("%d + %d = %d\n", x, y, xPLUSy)
    	fmt.Printf("%d * %d = %d\n", x, y, xTIMESy)
	}
	
Above example return two values without name, and you can name them also. If we named return values, we just use `return` to return values is fine because they initializes in the function automatically. Notice that if your functions are going to be used outside the package, which means your functions name start with capital letter, you'd better write complete statement for `return`; it makes your code more readable.

	func SumAndProduct(A, B int) (add int, Multiplied int) {
    	add = A+B
    	Multiplied = A*B
    	return
	}

###Variable arguments
Go supports variable arguments, which means you can give certain number of argument to functions. 

	func myfunc(arg ...int) {}

`arg …int` tells Go this is the function that has variable arguments. Notice that these arguments are type `int`. In the body of function, the `arg` becomes a `slice` of `int`.

	for _, n := range arg {
    	fmt.Printf("And the number is: %d\n", n)
	}
	
###Pass by value and pointers
When we pass an argument to the function that was called, that function actually gets the copy of our variables, any change will not affect to the original variable.

Let's see one example to prove my statement.

	package main
	import "fmt"

	// simple function to add 1 to a
	func add1(a int) int {
    	a = a+1 // we change value of a 
    	return a // return new value of a
	}

	func main() {
    	x := 3

    	fmt.Println("x = ", x)  // should print "x = 3"

    	x1 := add1(x)  // call add1(x)

    	fmt.Println("x+1 = ", x1) // should print "x+1 = 4"
    	fmt.Println("x = ", x)    // should print "x = 3"
	}
	
Did you see that? Even though we called `add1`, and `add1` adds one to `a`, the value of `x` doesn't change.

The reason is very simple: when we called `add1`, we gave a copy of `x` to it, not the `x` itself.

Now you may ask how I can pass the real `x` to the function.

We need use pointers here. We know varibales store in the memory, and they all have memory address, we change value of variable is to change the value in that variable's memory address. Therefore the function `add1` have to know the memory address of `x` in order to change its value. Here we pass `&x` to the function, and change argument's type to pointer type `*int`. Be aware that here we pass a copy of pointer, not copy of value.

	package main
import "fmt"

	// imple function to add 1 to a
	func add1(a *int) int { // attention，
    	*a = *a+1 // we changed value of a
    	return *a // return new value of a
	}

	func main() {
    	x := 3

    	fmt.Println("x = ", x)  // should print "x = 3"

    	x1 := add1(&x)  // call add1(&x) pass memory address of x

    	fmt.Println("x+1 = ", x1) // should print "x+1 = 4"
    	fmt.Println("x = ", x)    // should print "x = 4"
	}
	
Now we can change value of `x` in the functions. Why we use pointers? What're the advantages?

- Use more functions to operate one variable.
- Low cost by passing memory addresses (8 bytes), copy is not an efficient way in both time and space to pass variables.
- `string`, `slice`, `map` are reference types, so they use pointers when pass to functions as default. (Attention: If you need to change length of `slice`, you have to pass pointers explicitly)

###defer

![](images/2.3.init.png?raw=true)
##Links
- [Directory](preface.md)
- Previous section: [Go fundation](02.2.md)
- Next section: [struct](02.4.md)